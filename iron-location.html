<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer-element.html">

<!--

The `iron-location` element manages binding to and from the current URL.

iron-location is the first, and lowest level element in the Polymer team's
routing system. This is a beta release of iron-location as we continue work
on higher level elements, and as such iron-location may undergo breaking
changes.

#### Properties

When the URL is: `/search?query=583#details` iron-location's properties will be:

  - path: `'/search'`
  - query: `'query=583'`
  - hash: `'details'`

These bindings are bidirectional. Modifying them will in turn modify the URL.

iron-location is only active while it is attached to the document.

#### Links

While iron-location is active in the document it will intercept clicks on links
within your site, updating the URL pushing the updated URL out through the
databinding system. iron-location only intercepts clicks with the intent to
open in the same window, so middle mouse clicks and ctrl/cmd clicks work fine.

You can customize this behavior with the `urlSpaceRegex`.

#### Dwell Time

iron-location protects against accidental history spamming by only adding
entries to the user's history if the URL stays unchanged for `dwellTime`
milliseconds.

@demo demo/index.html

 -->
<script>
  (() => {
    'use strict';

    var workingURL;

    var urlDoc, urlBase, anchor;

    /**
     * @type {string} path
     * @type {string=} base
     * @return {URL|HTMLAnchorElement}
     */
    const resolveURL = (path, base) => {
      var url;
      if (workingURL === undefined) {
        workingURL = false;
        try {
          var u = new URL('b', 'http://a');
          u.pathname = 'c%20d';
          workingURL = (u.href === 'http://a/c%20d');
          workingURL = workingURL && (new URL('http://www.google.com/?foo bar').href === 'http://www.google.com/?foo%20bar');
        } catch (e) {}
      }
      if (workingURL) {
        url = new URL(path, base);
      } else {
        if (!urlDoc) {
          urlDoc = document.implementation.createHTMLDocument('url');
          urlBase = urlDoc.createElement('base');
          urlDoc.head.appendChild(urlBase);
          anchor = urlDoc.createElement('a');
        }
        urlBase.href = base;
        anchor.href = path.replace(/ /g, '%20');
        url = anchor;
      }
      return url;
    }

    class IronLocation extends Polymer.Element {
      static get is () { return 'iron-location'; }

      constructor() {
        super();
        this.__boundHashChanged = this._hashChanged.bind(this);
        this.__boundUrlChanged = this._urlChanged.bind(this);
        this.__boundGlobalOnClick = this._globalOnClick.bind(this);
      }

      static get properties () {
        return {
          /**
          * The pathname component of the URL.
          */
          path: {
            type: String,
            notify: true,
            value: function() {
              return window.decodeURIComponent(window.location.pathname);
            }
          },

          /**
          * The query string portion of the URL.
          */
          query: {
            type: String,
            notify: true,
            value: function() {
              return window.location.search.slice(1);
            }
          },

          /**
          * The hash component of the URL.
          */
          hash: {
            type: String,
            notify: true,
            value: function() {
              return window.decodeURIComponent(window.location.hash.slice(1));
            }
          },

          /**
          * If the user was on a URL for less than `dwellTime` milliseconds, it
          * won't be added to the browser's history, but instead will be replaced
          * by the next entry.
          *
          * This is to prevent large numbers of entries from clogging up the user's
          * browser history. Disable by setting to a negative number.
          */
          dwellTime: {
            type: Number,
            value: 2000
          },

          /**
          * A regexp that defines the set of URLs that should be considered part
          * of this web app.
          *
          * Clicking on a link that matches this regex won't result in a full page
          * navigation, but will instead just update the URL state in place.
          *
          * This regexp is given everything after the origin in an absolute
          * URL. So to match just URLs that start with /search/ do:
          *     url-space-regex="^/search/"
          *
          * @type {string|RegExp}
          */
          urlSpaceRegex: {
            type: String,
            value: ''
          },

          /**
          * urlSpaceRegex, but coerced into a regexp.
          *
          * @type {RegExp}
          */
          _urlSpaceRegExp: {
            computed: '_makeRegExp(urlSpaceRegex)'
          },

          _lastChangedAt: {
            type: Number
          },

          _initialized: {
            type: Boolean,
            value: false
          }
        }
      }

      static get hostAttributes () {
        return {
          hidden: true
        }
      }

      static get observers () {
        return [
          '_updateUrl(path, query, hash)'
        ]
      }

      connectedCallback () {
        super.connectedCallback();
        window.addEventListener('hashchange', this.__boundHashChanged);
        window.addEventListener('location-changed', this.__boundUrlChanged);
        window.addEventListener('popstate', this.__boundUrlChanged);
        window.document.body.addEventListener('click', this.__boundGlobalOnClick);

        // Give a 200ms grace period to make initial redirects without any
        // additions to the user's history.
        this._lastChangedAt = window.performance.now() - (this.dwellTime - 200)
        this._initialized = true;
        this._urlChanged();
      }

      disconnectedCallback() {
        super.disconnectedCallback()
        window.removeEventListener('hashchange', this.__boundHashChanged);
        window.removeEventListener('location-changed', this.__boundUrlChanged);
        window.removeEventListener('popstate', this.__boundUrlChanged);
        window.document.body.removeEventListener('click', this.__boundGlobalOnClick);
        this._initialized = false;
      }

      // Computed functions
      //---------------------------------------------------------------
      _makeRegExp(urlSpaceRegex) {
        return RegExp(urlSpaceRegex);
      }

      // Observer functions
      //---------------------------------------------------------------

      _updateUrl() {
        if (this._dontUpdateUrl || !this._initialized) {
          return;
        }
        if (this.path === window.decodeURIComponent(window.location.pathname) &&
            this.query === window.location.search.substring(1) &&
            this.hash === window.decodeURIComponent(window.location.hash.substring(1))) {
          // Nothing to do, the current URL is a representation of our properties.
          return;
        }
        var newUrl = this._getUrl();
        // Need to use a full URL in case the containing page has a base URI.
        var fullNewUrl = new URL(newUrl, window.location.protocol + '//' + window.location.host).href;
        var now = window.performance.now();
        var shouldReplace = this._lastChangedAt + this.dwellTime > now;
        this._lastChangedAt = now;
        if (shouldReplace) {
          window.history.replaceState({}, '', fullNewUrl);
        } else {
          window.history.pushState({}, '', fullNewUrl);
        }

        window.dispatchEvent(new CustomEvent('location-changed'));
      }

      _urlChanged() {
        // We want to extract all info out of the updated URL before we
        // try to write anything back into it.
        //
        // i.e. without _dontUpdateUrl we'd overwrite the new path with the old
        // one when we set this.hash. Likewise for query.
        this._dontUpdateUrl = true;
        this._hashChanged();
        this.path = window.decodeURIComponent(window.location.pathname);
        this.query = window.location.search.substring(1);
        this._dontUpdateUrl = false;
        this._updateUrl();
      }

      _getUrl() {
        var partiallyEncodedPath = window.encodeURI(this.path).replace(/\#/g, '%23').replace(/\?/g, '%3F');
        var partiallyEncodedQuery = '';
        if (this.query) {
          partiallyEncodedQuery = '?' + this.query.replace(/\#/g, '%23');
        }
        var partiallyEncodedHash = '';
        if (this.hash) {
          partiallyEncodedHash = '#' + window.encodeURI(this.hash);
        }
        return (partiallyEncodedPath + partiallyEncodedQuery + partiallyEncodedHash);
      }

      _globalOnClick(event) {
        // If another event handler has stopped this event then there's nothing
        // for us to do. This can happen e.g. when there are multiple
        // iron-location elements in a page.
        if (event.defaultPrevented) {
          return;
        }
        var href = this._getSameOriginLinkHref(event);
        if (!href) {
          return;
        }
        event.preventDefault();

        // If the navigation is to the current page we shouldn't add a history
        // entry or fire a change event.
        if (href === window.location.href) {
          return;
        }
        window.history.pushState({}, '', href);
        window.dispatchEvent(new CustomEvent('location-changed'));
      }


      _hashChanged() {
        this.hash = window.decodeURIComponent(window.location.hash.substring(1));
      }

      _getSameOriginLinkHref(event) {
        // We only care about left-clicks.
        if (event.button !== 0) {
          return null;
        }

        // We don't want modified clicks, where the intent is to open the page
        // in a new tab.
        if (event.metaKey || event.ctrlKey) {
          return null;
        }

        // http://stackoverflow.com/questions/39245488/event-path-undefined-with-firefox-and-vue-js
        var eventPath = event.path || (event.composedPath && event.composedPath());
        var anchor = null;
        for (var i = 0; i < eventPath.length; i++) {
          var element = eventPath[i];
          if (element.tagName === 'A' && element.href) {
            anchor = element;
            break;
          }
        }

        // If there's no link there's nothing to do.
        if (!anchor) {
          return null;
        }

        // Target blank is a new tab, don't intercept.
        if (anchor.target === '_blank') {
          return null;
        }

        // If the link is for an existing parent frame, don't intercept.
        if ((anchor.target === '_top' ||
            anchor.target === '_parent') &&
            window.top !== window) {
          return null;
        }
        var href = anchor.href;

        // It only makes sense for us to intercept same-origin navigations.
        // pushState/replaceState don't work with cross-origin links.
        var url;
        if (window.document.baseURI != null) {
          url = new URL(href, /** @type {string} */(window.document.baseURI));
        } else {
          url = new URL(href);
        }
        var origin;

        // IE Polyfill
        if (window.location.origin) {
          origin = window.location.origin;
        } else {
          origin = window.location.protocol + '//' + window.location.hostname;
          if (window.location.port) {
            origin += ':' + window.location.port;
          }
        }
        if (url.origin !== origin) {
          return null;
        }
        var normalizedHref = url.pathname + url.search + url.hash;

        // If we've been configured not to handle this url... don't handle it!
        if (this._urlSpaceRegExp && !this._urlSpaceRegExp.test(normalizedHref)) {
          return null;
        }
        // Need to use a full URL in case the containing page has a base URI.
        var fullNormalizedHref = new URL(normalizedHref, window.location.href).href;
        return fullNormalizedHref;
      }
    }

    window.customElements.define(IronLocation.is, IronLocation);
  })();
</script>
